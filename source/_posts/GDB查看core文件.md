title: GDB查看core文件
date: 2019-02-23 19:42:10
tags: [linux, coredump文件]
---

## 背景

当程序运行的过程中出现异常终止或者崩溃，操作系统会将当时的内存状态记录下来，保存在一个文件中，生成coredump文件（核心转储）。除了内存状态，其他的比如：寄存器信息（程序指针，栈信息），内存管理信息，其他处理器和操作系统状态也会记录。

<!-- more -->

## 产生core dump 文件的可能原因

1. 内存访问越界
 - 数组之类的下标越界
 - 搜索字符串时，利用字符串的结束符判断字符串是否结束，但是字符串没有正常的使用结束符
 - 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界
2. 多线程程序使用了线程不安全的函数。

3. 多线程读写的数据未加锁保护。对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump

4. 非法指针
 - 使用空指针
 - 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump.
5. 堆栈溢出.不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。

> 提醒：可以多运行几次程序，如果每次coredump 的位置不是同一个地方，那么就可能是内存写花了，或者是因为编译时加入了内存相关的优化参数，如：tcmalloc、ptmalloc等工具，可以先去掉这些试试看问题是否解决。

注意：查看coredump 文件只是找到出现问题的代码位置，而导致程序挂的原因还需要自己去分析。

## Linux 下coredump文件生成

在我们的开发机上通常是没有打开生成coredump文件的开关的。因为一般coredump文件会比较大。

可以通过命令 `ulimit -c` 查看系统是否开启coredump 文件生成，如果输出 0， 那么就是没有打开。可以通过 `ulimit -c unlimited` （应该是要使用root账户）来开启，同时不限制生成的coredump 文件大小。

当然，可以通过 `ulimit -c 553245`（file_size) 来设置生成的coredump的大小。当然，core文件的名称，保存的路径都是可以修改的，感兴趣可以百度。